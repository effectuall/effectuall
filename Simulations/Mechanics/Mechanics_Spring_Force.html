<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <link rel="icon" type="image/svg+xml" href="/icon.svg" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
  <title>Mechanics_Spring_Force in Interactive 3D Simulations</title>
  <link rel="stylesheet" type="text/css" href="../../css/page.css">
  <!-- meta tags example -->
  <meta name="keywords"
    content=" physics, 3D, interactive, simulation, webgl, threejs, freelance, creative,Mechanics_Spring_Force" />
  <meta name="author" content="sajith EP, effectuallearning@gmail.com" />
  <meta name="developer" content="" />
</head>
</head>

<body>
  <div id="container">
    <div id="header">
      <h2> with Interactive 3D Simulation</h2>
    </div>

    <div id="aSide">
      <iframe src="https://effectuall.github.io/Simulations/Mechanics_Spring_Force" id="iframe" name="iframe"
        title="Iframe Display"></iframe>
      <a id="viewButton" onclick="viewFunction()"><i class="fa fa-expand" aria-hidden="true"></i></a>
    </div>
  
    <div style="float: left; margin-right:10px;">
      <div style="float: none; margin-right:10px;">
          <img src="../../assets/img/block.png" id="block" style="width:20px; height:40px; margin-right: -5px; margin-bottom: -50px;">
          <img src="../../assets/img/spring3.png" id="springimg" style="width:150px; height:40px; margin-bottom: -50px;">

      </div>

      <canvas width="300px" height="600px" id="canvas"></canvas>
      <canvas width="300px" height="600px" id="canvas1"></canvas>
  </div>

  <div>
      <!-- <p style="font-size: 24px; ">Mass = <a id="mass"> </a>g</p> -->
      <div>
          <input type="range" id="mass" name="mass" min="5" max="500" value="100" step="5">
          <p> <label for="mass">MASS =</label><a id="massDisplay"></a>
              <span>grams</span>
          </p>

      </div>
      <div>
          <input type="range" id="springK" name="springK" min="100" max="1500" value="100" step="5">
          <p>
              <label for="springK">SPRING CONSTANT =</label><a id="springDisplay"></a>
          </p>
          <p>Angular frequency, <em>&omega; = (k/m)<sup>1/2</sup> =</em> <a id="freq"></a>rad<sup>-1</sup> </p>
          <p>Time Period, <em>T = 2 &pi;(m/k)<sup>1/2</sup> =</em> <a id="period"></a>s </p>
      </div>
      Amplitude = <a id="amp"></a>m
      <p><button id="plusbtn">+</button> <button id="minusbtn"><span> - </span></button></p>
      <p></p>

      <p><button id="pausebtn"> PAUSE </button></p>
  </div>
    
    <div id="part1" class="content">
      <h2>Simple Harmonic Motion</h2>
      <dl>
        <dt>
          &#160 &#xa0 &#10148 Repetitive back and forth movement through an equilibrium position.    
       </dt>
      </dl>
      
      <dl>
        <dt>
          &#160 &#xa0 &#10148 Maximum displacement on either side of the equilibrium position is equal.
        </dt>
      </dl> 
      <dl>
        <dt>
          &#160 &#xa0 &#10148 The time interval of each complete vibration (to and fro motion) is the same.
        </dt>
      </dl>

   
        <p>
          Any motion that repeats at regular intervals is called periodic motion or harmonic motion. 
          Here we are interested in a periodic motion of simple harmonic motion (SHM) type which can be
          represented using a sinusoidal function of time \(t\). In simple harmonic motion (SHM), the 
          displacement \(x(t)\) of a particle from its equilibrium position is described by the equation
          $$ x = x_{m} \cos(\omega t + \phi) $$
          in which \(x_{m}\) is the amplitude of the displacement, \((\omega t + \phi)\) is
          the phase of the motion, and \(\phi\) is the phase constant. The
          angular frequency \(\omega\) is related to the period and frequency of
          the motion by 
          $$\omega = \frac{2\pi}{T} = 2\pi f$$
         
          Differentiating \(x(t)\) leads to equations for the particle's SHM velocity and acceleration 
          as functions of time:
          <p>
            velocity
            $$v = - \omega x_{m} \sin(\omega t + \phi)  $$
          </p>
          <p>
           acceleration
            $$ a = -\omega^{2} x_{m} \cos(\omega t + \phi)  $$
            $$\begin{aligned} 
            a &= -\omega^{2} x_{m} \cos(\omega t + \phi) \\
            a &= -\omega^{2} x\\
            a &\propto -x \end{aligned}$$                
          </p>
          <dl>
            <dt>
              &#160 &#xa0 &#10148 In SHM, the acceleration is proportional to the position of the body and its direction is opposite the direction of the displacement from equilibrium position.
                 
           </dt>
          </dl> 
          In the velocity function, the positive quantity \(\omega x_{m} \) is the velocity amplitude \(v_{m} \).
          In the acceleration function, the positive quantity \(\omega^{2} x_{m} \) is the acceleration amplitude \(a_{m} \).
          <h2> SHM in a Spring </h2>
          <dl>
            <dt>
              &#160 &#xa0 &#10148 In SHM, the net force of the system, is proportional to the displacement and acts in the opposite direction of the displacement.
                 
           </dt>
          </dl> 
          
          A particle with mass \(m\) that moves under the influence of a
          Hooke's law restoring force given by \(F = -kx\) is a linear simple harmonic 
          oscillator with
          <p>
            Angular frequency,
            $$\omega = \sqrt \frac{k}{m} $$
          </p>
         <p>
           and Time Period,
          $$ T = \frac{2\pi}{\omega} = 2\pi\sqrt \frac{m}{k} $$
         </p>
         <h2> SHM in a Simple Gravity Pendulum </h2>
         <dl>
           <dt>
             &#160 &#xa0 &#10148 Here, the net weight of the bob acts downwards and the tension acts along the pendulum string. The tension 'T' depends on the amplitude but the period of oscillation is independent of the mass of the bob and the amplitude of the swing. 
          </dt>
         </dl> 
         <p>Period of oscillation of a simple pendulum depends only on the length of the string.
                
                \[ T = 2 \pi \sqrt \frac L g\]    

         </p>
    
    
      </div>    
    <div style="text-align: center;" id="counterCard">
      ___________________
      <p id="footer"></p>
      <p id="email"></p>
    </div>
  </div>
  <script>
    let iFrame = document.getElementById("iframe");
    let viewButton = document.getElementById("viewButton");
    function viewFunction() {
      viewButton.href = iFrame.src;
      viewButton.target = "_blank";

    }
  </script>
   <script>
    const canvas = document.getElementById('canvas');
    const canvasContext = canvas.getContext('2d');

    const pauseButton = document.getElementById('pausebtn');
    const plusButton = document.getElementById('plusbtn');
    const minusButton = document.getElementById('minusbtn');

    let springImg = document.getElementById('springimg');
    let massEl = document.getElementById('mass');
    let massDisplay = document.getElementById('massDisplay');
    let springEl = document.getElementById('springK');
    let springDisplay = document.getElementById('springDisplay');
    let freqDisplay = document.getElementById('freq');
    let periodDisplay = document.getElementById('period');
    let ampEl = document.getElementById('amp');

    let backgroundImage = new Image();
    backgroundImage.src = '../../assets/img/Graph-paper.png';
    let springK = springEl.valueAsNumber;
    let mass = massEl.valueAsNumber;
    let freq = 1;
    let period = 2 * Math.PI / freq;

    const cx = canvas.width / 2, cy = canvas.height / 4;
    let radius = 75, angle = 0, height = radius * 50;
    let t = period / 1000, T = 0;
    let requestID, imageID, pause = false;
    let newWidth = 250;
    let finalWidth = 150;
    let amp = 0.018;

    massDisplay.innerText = mass;
    springDisplay.innerText = springK;
    freqDisplay.innerText = freq;
    periodDisplay.innerText = period.toFixed(2);

    massEl.addEventListener("input", function (event) {
        // console.log(massEl.valueAsNumber )
        mass = massEl.valueAsNumber;
        freq = Math.sqrt(springK / mass);
        period = 2 * Math.PI / freq;
        massDisplay.innerText = mass;
        freqDisplay.innerText = freq.toFixed(2);
        periodDisplay.innerText = period.toFixed(2);
        t = period / 1000;
    });
    springEl.addEventListener("input", function (event) {
        // console.log(springEl.valueAsNumber )
        springK = springEl.valueAsNumber;
        freq = Math.sqrt(springK / mass);
        period = 2 * Math.PI / freq;
        springDisplay.innerText = springK;
        freqDisplay.innerText = freq.toFixed(2);
        periodDisplay.innerText = period.toFixed(2);
        t = period / 1000;
    });
    plusButton.addEventListener('click', function () {
        radius = radius + 10;
        // height = (radius-10)*radius/2;
        ampEl.innerText = radius;
        newWidth = newWidth + 10;
        springImg.style.width = `${newWidth}px`
    });
    minusButton.addEventListener('click', function () {
        radius = radius - 10;
        // height = (radius-10)*radius/2;
        ampEl.innerText = radius;
        newWidth = newWidth - 10;
        springImg.style.width = `${newWidth}px`
    });
    pauseButton.addEventListener('click', function () {
        pause = !pause
        if (pause) {
            console.log('pause');
            pauseButton.innerHTML = 'START';
            cancelAnimationFrame(requestID);
            // cancelAnimationFrame(imageID);
        } else {
            console.log('Start');
            pauseButton.innerHTML = 'PAUSE';
            plotCurve();
            // changeImage()
        }
    });
    let g = 0;
    plotCurve();


    function plotCurve() {
        let x = Math.cos(2.37 * freq * angle) * 1.3 * radius,
            y = Math.sin(freq * angle) * radius;
        // g = g + amp*10*Math.cos(freq*t)
        canvasContext.clearRect(0, 0, canvas.width, canvas.height);
        canvasContext.drawImage(backgroundImage, 0, 0);

        if (newWidth < finalWidth) {
            T = T + amp * Math.cos(freq * t);
            // T= T + x
            newWidth = newWidth + T;                
            // console.log('1')
        } else {
            T = T - amp * Math.cos(freq * t);
            newWidth = newWidth + T;                
            // console.log('2')
        }
        drawAxes(canvasContext, 70, 32, 270 + T, 32, 'red')
        springImg.style.width = `${newWidth}px`;

        canvasContext.beginPath();    
        canvasContext.lineWidth = 2;  
        canvasContext.fillStyle = 'black'; 
        canvasContext.fillRect(newWidth, 2, 20, 50);
        canvasContext.fill();
        canvasContext.closePath();

        canvasContext.beginPath();    
        canvasContext.lineWidth = 2;
        canvasContext.fillStyle = 'green';            
        canvasContext.arc(cx + x, 30 , 8, 0, Math.PI * 2);
        canvasContext.fill();
        canvasContext.closePath();
        drawCosine(canvasContext, 1.3 * radius, 2.37 * freq * angle, 'green', 30, cx)
        angle += t;
        requestID = requestAnimationFrame(plotCurve);
    }

    function drawAxes(ctx, x1, y1, x2, y2, col) {
        // console.log('axis')
        ctx.beginPath();
        ctx.strokeStyle = col;
        ctx.fillStyle = 'green';
        ctx.lineWidth = 2;
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2)
        ctx.stroke();
    }

    function drawCosine(ctx, A, t, col, xAxis, yAxis) {
        ctx.beginPath();
        ctx.strokeStyle = col;
        // Set the initial x and y, starting at 0,0 and translating to the origin on
        // the canvas.
        let y = t;
        let x = Math.cos(y);
        ctx.moveTo(A * x + yAxis, xAxis);


        // Loop to draw segments
        for (i = xAxis; i <= height; i += 5) {
            y = t + (-xAxis + i) / A;
            x = Math.cos(y);

            ctx.lineTo(A * x + yAxis, i);
        }
        ctx.stroke();
    }


    let canvas1 = document.getElementById("canvas1");
    let ctx = canvas1.getContext("2d");
    let cw = canvas1.width;
    let ch = canvas1.height;

    let cBez1 = [{ x: 0, y: 0 }, { x: 150, y: 400 }, { x: 300, y: 0 }]
    drawBez(cBez1);
    let cPoints1 = findCBezPoints(cBez1);

    let cBez2 = [{ x: 0, y: 500 }, { x: 150, y: 100 }, { x: 300, y: 500 }]
    drawBez(cBez2);
    let cPoints2 = findCBezPoints(cBez2);
    // setInterval(timeanim, 1);
    // console.log(cPoints, cPoints1, cPoints2)

    let index1 = 0;
    let opr = -1;
    let index2 = 0;
    function timeanim() {
        //reset view
        ctx.clearRect(0, 0, cw, ch);

        drawBez(cBez1);
        drawBez(cBez2);
        //draw dot
        ctx.fillStyle = 'red';
        ctx.beginPath();
        ctx.arc(cPoints1[index1].x, cPoints1[index1].y, 8, 0, Math.PI * 2);
        ctx.fill();
        ctx.font = "12px arial";
        ctx.fillStyle = "red";
        ctx.textAlign = "center";
        ctx.fillText("POTENTIAL ENERGY STORED IN THE SPRING", cw/2, 20);
        ctx.fillText("KINETIC ENERGY OF THE SPRING", cw/2, ch/2+150 );
        ctx.font = "18px arial";
        ctx.fillStyle = "black";
        ctx.fillText("TOTAL ENERGY FOR THE SPRING ", cw/2, ch/2 -50 );

        

        ctx.fillStyle = 'blue';
        ctx.beginPath();
        ctx.arc(cPoints2[index2].x, cPoints2[index2].y, 8, 0, Math.PI * 2);
        ctx.fill();

        //reversing the dot in motion

        if (index1 + opr > cPoints1.length - 2 || index1 + opr < 0) {
            opr *= -1;
        }

        if (index2 + opr > cPoints2.length - 2 || index2 + opr < 0) {
            opr *= -1;
        }
        index1 += opr;
        index2 += opr;
        requestAnimationFrame(timeanim)
    }

    function findLinePoints(b) {
        let startPt = b[0];
        let endPt = b[1];
        let pts = [b[0]];
        let lastPt = b[0];
        let tests = 500;
        for (let t = 0; t <= tests; t++) {
            // calc another point along the curve
            // let pt = getCubicBezierXYatT(b[0], b[1], b[2], b[3], t / tests);
            let pt = getLineXYatT(b[0], b[1], t / tests)
            // add the pt if it's not already in the pts[] array
            let dx = pt.x - lastPt.x;
            let dy = pt.y - lastPt.y;
            let d = Math.sqrt(dx * dx + dy * dy);
            let dInt = parseInt(d);
            if (dInt > 0 || t == tests) {
                lastPt = pt;
                pts.push(pt);
            }
        }

        console.log(pts)
        return (pts);
    }


    function findCBezPoints(b) {
        let startPt = b[0];
        let controlPt1 = b[1];
        let controlPt2 = b[2];
        let endPt = b[3];
        let pts = [b[0]];
        let lastPt = b[0];
        let tests = 5000;
        for (let t = 0; t <= tests; t++) {
            // calc another point along the curve
            // let pt = getCubicBezierXYatT(b[0], b[1], b[2], b[3], t / tests);
            let pt = getQuadraticBezierXYatT(b[0], b[1], b[2], t / tests)
            // add the pt if it's not already in the pts[] array
            let dx = pt.x - lastPt.x;
            let dy = pt.y - lastPt.y;
            let d = Math.sqrt(dx * dx + dy * dy);
            let dInt = parseInt(d);
            if (dInt > 0 || t == tests) {
                lastPt = pt;
                pts.push(pt);
            }
        }
        return (pts);
    }

    function getLineXYatT(startPt, endPt, T) {
        let dx = endPt.x - startPt.x;
        let dy = endPt.y - startPt.y;
        let X = startPt.x + dx * T;
        let Y = startPt.y + dy * T;
        return ({ x: X, y: Y });
    }
    // Given the 4 control points on a Bezier curve 
    // Get x,y at interval T along the curve (0<=T<=1)
    // The curve starts when T==0 and ends when T==1
    function getCubicBezierXYatT(startPt, controlPt1, controlPt2, endPt, T) {
        let x = CubicN(T, startPt.x, controlPt1.x, controlPt2.x, endPt.x);
        let y = CubicN(T, startPt.y, controlPt1.y, controlPt2.y, endPt.y);
        return ({ x: x, y: y });
    }

    function getQuadraticBezierXYatT(startPt, controlPt, endPt, T) {
        let x = Math.pow(1 - T, 2) * startPt.x + 2 * (1 - T) * T * controlPt.x + Math.pow(T, 2) * endPt.x;
        let y = Math.pow(1 - T, 2) * startPt.y + 2 * (1 - T) * T * controlPt.y + Math.pow(T, 2) * endPt.y;
        return ({ x: x, y: y });
    }
    // cubic helper formula
    function CubicN(T, a, b, c, d) {
        let t2 = T * T;
        let t3 = t2 * T;
        return a + (-a * 3 + T * (3 * a - a * T)) * T + (3 * b + T * (-6 * b + b * 3 * T)) * T + (c * 3 - c * 3 * T) * t2 + d * t3;
    }

    function drawPlots(pts) {
        ctx.fillStyle = 'red';
        // don't draw the last dot b/ its radius will display past the curve
        for (let i = 0; i < pts.length - 1; i++) {
            ctx.beginPath();
            ctx.arc(pts[i].x, pts[i].y, 1, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    function drawBez(b) {
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(b[0].x, b[0].y);
        ctx.quadraticCurveTo(b[1].x, b[1].y, b[2].x, b[2].y);
        // ctx.bezierCurveTo(b[1].x, b[1].y, b[2].x, b[2].y, b[3].x, b[3].y);
        ctx.stroke();
    }

    function drawLine(ctx, b) {

        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(b[0].x, b[0].y);
        ctx.lineTo(b[1].x, b[1].y)
        ctx.stroke();
    }
    timeanim();
</script>
  <script type="module" src="../../footer.js"></script>
</body>

</html>